Example Projects!
=================
Here are a few example projects to show just how easy the API is to use.

Voltmeter using the 16-bit Delta-Sigma ADC
++++++++++++++++++++++++++++++++++++++++++
This program demonstrates basic usage of the RPiSoC's DELSIG ADC as a Voltmeter.

The program will output the voltage of whatever is connected to P15[5] every .1
seconds.

Note that P5[0], which is a 3.3V pin (slightly higher when powering with the Pi)
is initialized as HIGH, and so connecting to to P0[3] should show between 3.2
and 3.5V.

The Power supply on each port should read close to 5V as well.
You can confirm the accuracy with a Voltmeter

Note: Px[y] means Port x, Pin y.
code::

	from rpisoc import * 
	RPiSoC('SPI') 

	My_DELSIG  = ADC('DELSIG')
	My_DELSIG.Start()

	out_3v3 = digitalPin(5,0,'OUT') 
	out_3v3.Write(1)

	try: 
		while True:
			ADC_counts = My_DELSIG.Read()
			Voltage = My_DELSIG.CountsTo_Volts(ADC_counts)

			print('ADC OUTPUT: %d' %ADC_counts)
			print('VOLTAGE:    %.3f' %Voltage)

			time.sleep(.1)
	except KeyboardInterrupt:
		RPiSoC.commChannel.cleanup()

Voltmeter using the 12-bit Successive Approximation ADC
+++++++++++++++++++++++++++++++++++++++++++++++++++++++
This is the same concept as the previous example, except it is done in a totally different way using the SAR ADC. Here, we are using the *StartConvert()* and *StopConvert()* methods to manually control each conversion, instead of using *Read()* like in the above example, which hides that functionality. 

Remember that the SAR ADC being used here is on P15[4] now, not P15[5] like in the previous example!

code::

    from rpisoc import *

    RPiSoC('SPI')

    My_SAR_ADC = ADC('SAR0')

    out_3v3 = digitalPin(5,0,'OUT')
    out_3v3.Write(1)

    try:
        while True:
            My_SAR_ADC.Start()
            #My_SAR_ADC.SetOffset(40)
            My_SAR_ADC.StartConvert()

            while not My_SAR_ADC.IsEndConversion():
                pass

            Counts = My_SAR_ADC.GetResult()
            My_SAR_ADC.StopConvert()
            My_SAR_ADC.Stop()

            Volts = My_SAR_ADC.CountsTo_Volts(Counts)
            print('ADC OUTPUT:\t %d \nVOLTAGE:\t %.5f Volts \n' %(Counts, Volts))

            time.sleep(0.1)


    except KeyboardInterrupt:
        RPiSoC.commChannel.cleanup()

Simple PWM Demo
+++++++++++++++
This program demonstrates basic use of the PWM channels on the RPiSoC.

To see the desired output, connect an LED to P6[0] and P6[2]

The program will initialize two PWM objects, one of which will remain blinking
with the same duty cycle and frequency, while the other will change according to user input

While the program runs, the user will give terminal commands to modify the PWM's
period, comparison values, duty cycle, clock frequency, or wave frequency. These changes will then be read back by the RPiSoC, and displayed on the terminal.

code::

    from rpisoc import *

    RPiSoC('SPI')

    My_PWM = PWM(0)
    My_other_PWM = PWM(2)

    My_PWM.Start()
    My_other_PWM.Start()
    My_PWM.WritePeriod(65535)
    My_other_PWM.WritePeriod(65535)
    My_PWM.SetDutyCycle(50)
    My_other_PWM.SetDutyCycle(50)

    try:
        while True:
            print('\nMy_PWM: \t\t\t My_other_PWM: \nPERIOD: %d \t\t\t PERIOD: %d \nCOMPARE: %d \t\t\t COMPARE: %d \nDUTY CYCLE: %.2f%s \t\t DUTY CYCLE: %.2f%s \nCLOCK RATE: %d Hz \t\t CLOCK RATE: %d Hz\nWAVE FREQ: %.3f Hz \t\t WAVE FREQ: %.3f Hz' %(My_PWM.ReadPeriod(), My_other_PWM.ReadPeriod(),My_PWM.ReadCompare(), My_other_PWM.ReadCompare(), My_PWM.GetDutyCycle(), '%', My_other_PWM.GetDutyCycle(), '%',My_PWM.GetClocks(), My_other_PWM.GetClocks(), My_PWM.GetFrequency(), My_other_PWM.GetFrequency()))

            choice = raw_input('\nChange [P]eriod [D]uty Cycle [C]omparison Value or [F]requency: ')
            if choice =='P' or choice =='p':
                new_period = int(raw_input('New Period: '))
                My_PWM.WritePeriod(new_period)

            elif choice == 'C' or choice == 'c':
                new_compare = int(raw_input('New Compare: '))

                My_PWM.WriteCompare(new_compare)

            elif choice == 'D' or choice == 'd':
                new_DC = int(raw_input('New Duty Cycle: '))
                My_PWM.SetDutyCycle(new_DC)

            elif choice == 'F' or choice ==  'f':
                new_choice = raw_input('[W]ave frequency or [C]lock frequency?')
                if new_choice == 'C' or new_choice =='c':
                    new_clk_freq = float(raw_input('New clock frequency: '))
                    My_PWM.SetClocks(new_clk_freq)
                elif new_choice == 'W' or new_choice == 'w':
                    new_wave_freq = float(raw_input('New wave frequency: '))
                    My_PWM.SetFrequency(new_wave_freq)
                else:
                    print ('Invalid input!!!')

            else:
                print ('Invalid input!!!')


    except KeyboardInterrupt:
        RPiSoC.commChannel.cleanup()





Simple usage of  digital inputs and outputs
+++++++++++++++++++++++++++++++++++++++++++
To set this demo up, wire P12[0], P12[1], P5[0], and P5[1] to LEDs in series
with a resistor. Also wire the outputs to one of the initialized inputs, in the following way:
	- wire P12[0] to P4[0]
	- wire P12[1] to P4[1]
	- wire P5[0] to P5[4]
	- wire P5[1] to P5[5]

The demo should light the LEDS in forwards order, and then turn off the LEDs in
reverse order

The terminal will output the state of the inputs at each step, along with their port/pin number and they should
correlate with the LEDs (if wired in the way noted above)

code::

    from rpisoc import *
    import os
    RPiSoC('SPI')

    My_outputs = [digitalPin(12,0,'OUT'), digitalPin(12,1,'OUT'), digitalPin(5,0,'OUT'), digitalPin(5,1,'OUT')]
    My_inputs = [digitalPin(4,0,'IN'), digitalPin(4,1,'IN'), digitalPin(5,4,'IN'), digitalPin(5,5,'IN')]

    try: #exception handling
        while True:
            for i in My_outputs: #Writes each output high, one by one, in forwards order
                i.Write(1)
                os.system('clear')
                for inputs in My_inputs:#Prints the state of each input
                    print ("P%d[%d]:%d" %(inputs.port, inputs.pin, inputs.Read()))
                time.sleep(1)

            for i in reversed(My_outputs):#Turns off the LEDs in reverse order
                i.Write(0)
                os.system('clear')
                for inputs in My_inputs:#Prints the state of each input
                    print ("P%d[%d]:%d" %(inputs.port, inputs.pin, inputs.Read()))
                time.sleep(1)




    except KeyboardInterrupt:
        RPiSoC.commChannel.cleanup()


Function Generator!
+++++++++++++++++++
This program demonstrates the use of the RPiSoC's WaveDAC.

It will begin by initializing a WaveDAC object and generating it's default wave, which happens to be a 4V 2.5kHz Sine wave, with no DC Bias. It will then wait for the user to choose to generate a new wave, and ask for
the configuration details.

Once it receives these values, it will stop the current wave, load the new configuration, and restart the wave to the users specifications!

To see the desired functionality, connect P0[0] to an Oscilliscope(or to another RPiSoC with the Oscilliscope program running!)

code::

	from rpisoc import *

	RPiSoC('SPI') #Establish connection to RPiSoC over SPI

	My_Wave = WaveDAC()
	My_Wave.Start() #Starts the default wave


	try: #exception handling, not crucial but it is advised.
		while True:
			print('My_Wave Frequency: ', My_Wave.GetFrequency())
			w_type = raw_input("Input Wave Type (SINE TRIANGLE SAWTOOTH or SQUARE) ")
			dcB = float(raw_input('Input DC Bias in Volts (0-4)'))
			amp = float(raw_input('Input amplitude in Volts (0-4) ' ))
			freq = int(raw_input('Input Frequency in Hz (46 - 2500) '))

			My_Wave.setAmplitude(amp)
			My_Wave.setdcBias(dcB)
			My_Wave.SetFrequency(freq)

			My_Wave.Stop() #Stops waveform generator to prepare for loading a new one
			My_Wave.Generate_Wave(w_type)
			My_Wave.Start() #Restarts the waveDAC with the new wave loaded

	except KeyboardInterrupt:
		RPiSoC.commChannel.cleanup()

Servo testing
+++++++++++++

This is a test for the Servo class. It will initialize three servo objects with default paramaters, and then the user will have the option to modify the first servo, and watch that the changes are reflected in the terminal
as well as by the servomotor itself.

Connect three servos to P6[0], P6[1], and P6[2] to see the desired results.
P6[0] should be moved according to user input, while the other two should be
held at a constant position. 

code::

    from rpisoc import *

    RPiSoC('SPI')

    My_servo = Servo(0) #simple init
    My_other_servo = Servo(1,1.2,2.5) #init with custom min and max pulse widths
    My_last_servo = Servo(2,1.0,2.5,0,180) # init with custom min and max pulse widths, and custom min and max angles.

    My_servo.Start()
    My_other_servo.Start()
    My_last_servo.Start()

    try:
        while True:
            print('\nServo\tPeriod\t\tPulse Width\n1    :\t%.2f ms\t%.2f ms\n2    :\t%.2f ms\t%.2f ms\n3    :\t%.2f ms\t%.2f ms\n' %(1000.0/My_servo.servo_PWM.GetFrequency(), My_servo.ReadPulse(), 1000.0/My_other_servo.servo_PWM.GetFrequency(), My_other_servo.ReadPulse(), 1000.0/My_last_servo.servo_PWM.GetFrequency(), My_last_servo.ReadPulse() ))

            choice = raw_input('Change [P]ulse width or [A]ngle')
            if choice == 'P' or choice == 'p':
                pulse_new = float(raw_input('New pulse width: '))
                My_servo.SetPulse(pulse_new)
            elif choice == 'A' or choice == 'a':
                angle_new = float(raw_input('New angle: '))
                My_servo.SetAngle(angle_new)
    except KeyboardInterrupt:
        RPiSoC.commChannel.cleanup()


.. codeauthor:: Brian Bradley <embedit@embeditelectronics.com>
.. sectionauthor:: Brian Bradley <embedit@embeditelectronics.com>